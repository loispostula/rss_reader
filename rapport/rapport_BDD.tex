\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
 \usepackage{latexsym}
\usepackage{listings}
\usepackage{amssymb, amsmath}
\usepackage[usenames,dvipsnames]{color}

\usepackage{tikz}

\usepackage{geometry}
 \geometry{
 a4paper,
 total={210mm,297mm},
 left=20mm,
 right=20mm,
 top=20mm,
 bottom=20mm,
 }

\lstset{
  breaklines=true,                                     % line wrapping on
  language=SQL,
  frame=ltrb,
  framesep=5pt,
  basicstyle=\normalsize,
  keywordstyle=\ttfamily\color{ForestGreen},
  identifierstyle=\ttfamily\color{NavyBlue}\bfseries,
  commentstyle=\color{Brown},
  stringstyle=\ttfamily,
  showstringspaces=true,
  numbers=left
}


\begin{document}
\begin{titlepage}
	\begin{center}
	\textbf{\textsc{UNIVERSIT\'E LIBRE DE BRUXELLES}}\\
	\textbf{\textsc{Faculté des Sciences}}\\
	\textbf{\textsc{Département d'Informatique}}
	\vfill{}\vfill{}
	\begin{center}{\Huge INFO-H-303 Bases de données : Rapport de projet -- Partie 2}\end{center}{\Huge \par}
	\begin{center}{\large \textsc{Postula} Loïs \\\textsc{Picard} Simon}\end{center}{\Huge \par}
	\vfill{}\vfill{}
	\vfill{}\vfill{}\enlargethispage{3cm}
	\textbf{Année académique 2013~-~2014}
	\end{center}
	\end{titlepage}
	
    \pagebreak

    \section{Modélisation entités-relations}

    Nous avons ici la modélisation entités-relations du projet. Les quelques points floux seront éclaircis ici:
    
    \begin{enumerate}
	\item Lorsqu'un User1 désire effectuer une demande d'amitier il demande a un autre User2 qui peut ou non accepter. Si User2 accepte les Users sont 'Friends'. La demande ne peut être acceptée que par User2 si elle
	a été demandée par User1.
	\item Une Publication peut se trouver dans de multiples Feeds : toujours son feed d'origine mais aussi des feeds partagés des Users et donc dans leur Personal Feeds.
	\item Un Comment ne doit etre affiché que pour certaines Feeds. En effet, le User ne peut qu'écrire un Comment que lorsqu'il l'a Share ou si elle lui a été Share. Comme il ne peut y avoir qu'un Comment par Publication d'un Feed, ces trois éléments sont suffisants pour identifier un Comment.
    \end{enumerate}

    \section{Modélisation relationnelle}

        User : \textbf{email}, password, nickname, city, country, avatar, \textit{biography}, subscription date.
            seul le champ \textit{biography} peut être nul
            \begin{itemize}            
             \item \textit{subscription date} ne peut être dans le futur
             \item \textit{email} doit respecter le format d'e-mail
             \item \textit{city} implique \textit{pays}
            \end{itemize}


        Feed(\textbf{URL}, title, description, \textit{link})
            \begin{itemize}
            \item \textit{URL} doit être une URL valide
	    \end{itemize}
        
        Publication(\textbf{URL}, title, releaseDate, description)
        \begin{itemize}            
            \item \textit{releaseDate} ne peut être dans le futur
        \end{itemize}

        Comment(\textbf{user, publication, feed}, date, text)
        \begin{itemize}
            \item \textit{user} référence \textit{User.email}
            \item \textit{publication} référence \textit{Publication.URL}
            \item \textit{feed} référence \textit{Feed.URL}
            \item \textit{date} ne peut être dans le futur
        \end{itemize}
        
        Friend(\textbf{user\_1, user\_2}, accepted)
        \begin{itemize}            
            \item \textit{user\_1} référence \textit{User.email}
            \item \textit{user\_2} référence \textit{User.email}
        \end{itemize}

        Subscribes(\textbf{user, feed})
        \begin{itemize}            
            \item \textit{user} référence \textit{User.email}
            \item \textit{feed} référence \textit{Feed.URL}
        \end{itemize}

        Read(\textbf{user, publication})
        \begin{itemize}            
            \item \textit{user} référence \textit{User.email}
            \item \textit{publication} référence \textit{Publication.URL}
        \end{itemize}
            
        Contains(\textbf{feed, publication})
        \begin{itemize}            
            \item \textit{feed} référence \textit{Feed.URL}
            \item \textit{publication} référence \textit{Publication.URL}
        \end{itemize}
            
        Share(\textbf{user, publication, feed}, date, text)
        \begin{itemize}
			\item seul le champ \textit{text} peut être nul
            \item \textit{user} référence \textit{User.email}
            \item \textit{publication} référence \textit{Publication.URL}
            \item \textit{feed} référence \textit{Feed.URL}
            \item \textit{date} ne peut être dans le futur
        \end{itemize}
		
\section{Script SQL DDL}
		
\section{Requêtes}
\subsection{Requête 1}
Tous les utilisateurs qui ont au plus 2 amis.
\subsubsection{SQL}
\begin{lstlisting}
SELECT * FROM user u
LEFT OUTER JOIN friendship f
ON
(
f.user1_email = u.email
OR
f.user2_email = u.email
)
GROUP BY u.email
HAVING COUNT(u.email) < 3
\end{lstlisting}
\subsubsection{Algèbre relationnel}
\begin{center}
\begin{tabular}{lll}
$Request$		& $\leftarrow$ & $ user\sqsupset\Join_{email=user1\_email \vee email=user2\_email}( friendship)$\\
$Request\_Accepted$	& $\leftarrow$ & $ \sigma_{accepted=TRUE}\ (Request)$\\
$Result$		& $\leftarrow$ & $ \pi_* (email\ \sigma_{COUNT(email)\ <\ 3}\ (Request_Accepted) )$ 
\end{tabular}
\end{center}

\subsubsection{Calcul relationnel tuple}
Définissons le prédicat \emph{Friends(user1, user2)} comme étant:
\\
      $Friends(u_1, u_2):\ \exists\ d\ (Friendship(d)\ \wedge $\\
      $(d.user_1\_email\ =\ u_1.email\ \vee\ d.user_2\_email\ =\ u_2.email)\ \wedge $\\
      $(d.user_2\_email\ =\ u_1.email\ \vee\ d.user_1\_email\ =\ u_2.email)\ \wedge $\\
      $d.accepted\ =\ 1$

La requête devient alors:

       $u | User(u) \wedge$ \\
       $\exists friend_1 ((User(friend_1) \wedge Friends(u, friend_1)) \rightarrow$ \\
       $\exists friend_2 ((User(friend_2) \wedge friend_1 \neq friend_2 \wedge Friends(u, friend_2)) \rightarrow$ \\
       $\nexists friend_3 ((User(friend_3) \wedge friend_1 \neq friend_2 \neq friend_3 \wedge Friends(u, friend_3)))))$
\clearpage
\subsection{Requête 2}
La liste des flux auxquels a souscrit au moins un utilisateur qui a souscrit à au moins deux flux auxquel X
a souscrit.
\subsubsection{SQL}
\begin{lstlisting}
SELECT * FROM feed f
INNER JOIN feedsubscription c ON c.feed_url = f.url
INNER JOIN 
  (
  SELECT b.user_email FROM feedsubscription b 
  INNER JOIN 
    (SELECT feed_url FROM feedsubscription WHERE user_email = <user>.email) a
  ON a.feed_url = b.feed_url 
  GROUP BY b.user_email
  HAVING COUNT(b.user_email) > 1
  ) d
ON d.user_email = c.user_email
GROUP BY c.feed_url
\end{lstlisting}
\subsubsection{Algèbre relationnel}
\begin{center}
\begin{tabular}{lll}
$a$		& $\leftarrow$ & $ \pi_{feed\_url}\ (\sigma_{user\_email=<user>.email}\ (feedsubscription)$\\
$b$		& $\leftarrow$ & $ \pi_{user\_email, feed\_url}\ (feedsubscription)$\\
$b\_a\_join$	& $\leftarrow$ & $ b \Join_{a.feed\_url=b.feed\_url}\ (a)$\\
$d$		& $\leftarrow$ & $ \pi_{b.user\_email}\ (b.user\_email\ \sigma_{COUNT(b.user\_email)\ >\ 1} (b\_a\_join))$\\
$c$		& $\leftarrow$ & $ feedsubscription \Join_{feed\_url=url}\ (f)$\\
$c\_d\_join$	& $\leftarrow$ & $ c \Join_{c.user\_email=d.user\_email} (d)$\\
$Result$	& $\leftarrow$ & $ \pi_*\ (c.feed\_url\ c\_d\_join)$
\end{tabular}
\end{center}

\subsubsection{Calcul relationnel tuple}
\clearpage
\subsection{Requête 3}
La liste des flux auxquels X a souscrit, auxquels aucun de ses amis n’a souscrit et duquel il n’a partagé
aucune publication.
\subsubsection{SQL}

\begin{lstlisting}
SELECT * FROM feed f
INNER JOIN feedsubscription fs1 
  ON 
  fs1.feed_url=f.url AND fs1.user_email = <user>.email
WHERE NOT EXISTS 
  (
  SELECT c1.feed_url FROM contain c1
    INNER JOIN contain c2 
      ON 
      c2.publication_url = c1.publication_url
      AND 
      c2.feed_url = "feed://" + <user>.email
  WHERE c1.feed_url=f.url 
  )
AND NOT EXISTS 
  (
  SELECT fs2.feed_url FROM feedsubscription fs2
    INNER JOIN friendship fr 
    ON 
      (
	fr.user1_email = fs2.user_email
	AND
	fr.user2_email = <user>.email
      )
      OR 
      (
	fr.user2_email = fs2.user_email
	AND
	fr.user1_email = <user>.email
      )
      AND 
	accepted = TRUE
   )
WHERE fs2.feed_url = f.url"

\end{lstlisting}
\subsubsection{Algèbre relationnel}
\begin{center}
\begin{tabular}{lll}
$Shared\_Feeds$ & $\leftarrow$ & $contain \Join_{publication\_url\_1=publication\_url\_2 \wedge feed\_url\_2 = {user.email}}\ (contain)$\\
$Shared\_Feed\_URL$ & $\leftarrow$ & $\pi_{feed_url} \sigma_{feed\_url\_2=url}\ (Shared\_Feeds)$\\
$Friend\_Feeds$ & $\leftarrow$ & $feedsubscription \Join_{((user1\_email=email \wedge user2\_email={user.email}) }$\\
&&$_{\vee (user2\_email=email \wedge user2\_email=[user.email]))} $\\
&&$_{\wedge accepted=TRUE}\ (friendship)$\\
$Friend\_Feed\_URL$ & $\leftarrow$ & $\pi_{feed\_url} \sigma_{feed\_url=url}\ (Friend\_Feeds)$\\
$User\_Feed$ & $\leftarrow$ & $feed \Join_{feed\_url=url \wedge user\_ema1l={user.email}}\ (feedsubscription)$\\
$Result$ & $\leftarrow$ & $(User\_Feed - Shared\_Feed\_URL) - Friend\_Subscribed\_URL$
\end{tabular}
\end{center}

\subsubsection{Calcul relationnel tuple}

\begin{equation*}
 \begin{split}
  \{\ f |\ feed(f)\ \wedge\ \\
  &\quad (\ \exists\ s\ (feedsubscription(s)\ \wedge\ (\ s.feed\_url\ =\ f.url\ \wedge\ s.user\_email\ =\ <\text{user}>.email\ ))\   \wedge \\
  &\quad \quad(\nexists\ c\ (contain(c)\ \wedge\ \exists\ d\ (contain(d)\ \wedge\ d.publication\_url = c.publication\_url\ \wedge\ \\
  &\qquad \qquad d.feed\_url = \text{"feed:// + "}<\text{user}>.email) )\ \wedge \\
  &\quad (\nexists\ e\ (feedsubscription(e)\ \wedge\ \exists\ fs\ (friendship(fs)\ \wedge\ \\
  &\qquad \qquad ((fs.user1\_email\ =\ e.user\_email\ \wedge\ fs.user2\_email\ =\ <\text{user}>.email)\\
  &\qquad \qquad \vee\\
  &\qquad \qquad (fs.user2\_email\ =\ e.user\_email\ \wedge\ fs.user1\_email\ =\ <\text{user}>.email))\\
  &\qquad \qquad \wedge\\
  &\qquad \qquad (fs.accepted\ =\ 1))))\ \wedge \\
  &\quad (e.feed\_url = f.url)
  \end{split}
\end{equation*}

\subsection{Requête 4}
La liste des utilisateurs qui ont partagé au moins 3 publications que X a partagé.
\subsubsection{SQL}
\begin{lstlisting}
SELECT * FROM user u
INNER JOIN sharedpublication s ON s.user_email = u.email
INNER JOIN 
  (
  SELECT publication_url FROM sharedpublication 
  WHERE user_email = <user>.email
  ) a
ON s.publication_url = a.publication_url
GROUP BY s.user_email
HAVING COUNT(s.user_email) > 2
\end{lstlisting}
\subsubsection{Algèbre relationnel tuple}
\begin{center}
\begin{tabular}{lll}
$a$		& $\leftarrow$ & $\pi_{publication\_url}\ (\ \sigma_{user\_email=<user>.email}\ (sharedpublication))$\\
$s$		& $\leftarrow$ & $user \Join_{email = user\_email} (sharedpublication)$\\
$a\_s\_join$	& $\leftarrow$ & $a \Join_{a.publication\_url=s.publication_url} (s)$\\
$Result$	& $\leftarrow$ & $\pi_*\ (s.user\_email\ \sigma_{COUNT(s.user_email) > 2} (a\_s\_join))$
\end{tabular}
\end{center}

\subsubsection{Calcul relationnel tuple}
\clearpage
\subsection{Requête 5}
La liste des flux auquel un utilisateur est inscrit avec le nombre de publications lues, le nombre de publications
partagées, le pourcentage de ces dernières par rapport aux premières, cela pour les 30 derniers jours et ordonnée
par le nombre de publications partagées.
\subsubsection{SQL}
\begin{lstlisting}
SELECT f.url, f.title, f.description, f.link, f.image, 
(
  SELECT COUNT(*) FROM readstatus rs 
  WHERE 
    rs.feed_url = f.url
  AND 
    rs.user_email = fs2.user_email
  AND 
    TO_DAYS(NOW())-TO_DAYS(rs.date) < 30
)
AS nread,
(
  SELECT COUNT(*) FROM sharedpublication sp
  INNER JOIN feedsubscription fs 
    ON 
      sp.user_email = fs.user_email
  INNER JOIN contain c 
    ON 
	fs.feed_url = c.feed_url
      AND 
	sp.publication_url = c.publication_url
  WHERE 
    c.feed_url = f.url
  AND 
    sp.user_email = fs2.user_email
  AND 
    TO_DAYS(NOW())-TO_DAYS(sp.sharedDate) < 30
) 
AS nshared,
( 
  SELECT nshared/nread 
)
AS ratio 
FROM feed f
INNER JOIN feedsubscription fs2 
ON 
  fs2.feed_url = f.url
WHERE 
  fs2.user_email = <user>.email 
GROUP BY 
  f.url 
ORDER BY nshared
\end{lstlisting}
\clearpage
\subsection{Requête 6}
La liste des amis d’un utilisateur avec pour chacun le nombre de publications lues par jour et le nombre
d’amis, ordonnée par la moyenne des lectures par jour depuis la date d’inscription de cet ami

\subsubsection{SQL}
\begin{lstlisting}
SELECT u.*,
(
  SELECT COUNT(*) FROM readstatus rs 
  WHERE 
  rs.user_email = u.email)/(TO_DAYS(NOW())-TO_DAYS(u.joinedDate)
) 
AS mread,
(
  SELECT COUNT(u2.email) FROM user u2
  INNER JOIN friendship f2 
  ON 
      f2.user1_email = u2.email 
    OR 
      f2.user2_email = u2.email
  WHERE 
  u2.email = u.email 
  GROUP BY u2.email
) 
AS nfriend
FROM user u
INNER JOIN friendship f 
ON 
    f.user1_email = u.email 
  OR 
    f.user2_email = u.email
WHERE 
  (
    f.user1_email = <user>.email 
  AND 
    u.email <> f.user1_email
  ) 
OR 
  (
    f.user2_email = <user>.email 
  AND 
    u.email <> f.user2_email
  )
ORDER BY mread
\end{lstlisting}
		
\section{Instructions d'installation}
		
\section{Scénario de démonstration}
		
\section{Hypothèse}
\end{document}
